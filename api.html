<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<title>libgit2 API</title>
		<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
		<link href="stylesheets/application.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="stylesheets/sunburst.css" media="all" rel="stylesheet" type="text/css"/>
		<script type="text/javascript" src="js/sh_main.min.js"></script>
		<script type="text/javascript" src="js/sh_lang/sh_c.min.js"></script>
		<script type="text/javascript" src="js/sh_lang/sh_ruby.min.js"></script>
		<link type="text/css" href="stylesheets/sh_libgit.css" rel="stylesheet" >
	</head>

	<body onload="sh_highlightDocument();">
		<div id="body"><div id="contents">
			<div id="header">
        <h1>LibGit2 API Usage Guide</h1>
			</div>

			<h2 id="content">Contents</h2>
			<div class="contents"><div class="bullet">
				<div class="description">
					<ul>
						<li><a href="api.html#sha">SHA conversions and formatting</a></li>
						<li><a href="api.html#rawread">object reading (loose and packed)</a></li>
						<li><a href="api.html#rawwrite">object writing (loose)</a></li>
						<li><a href="api.html#parsing">commit, tag, tree and blob parsing and write-back</a></li>
						<li><a href="api.html#trees">tree traversal</a></li>
						<li><a href="api.html#revwalk">revision walking</a></li>
						<li><a href="api.html#index">index file (staging area) manipulation</a></li>
					</ul>
				</div>
			</div></div>

			<h2 id="started">Getting started</h2>

			<div class="contents"><div class="bullet">
				<div class="description">
					<p>This is the usage guide for the libgit2 API.  The machine generated
						documentation for the C API can be found <a href="http://libgit2.github.com/libgit2/modules.html">here</a>;
						this page is to show some examples and usage of libgit2 and the Ruby
						bindings, <a href="https://github.com/libgit2/rugged">Rugged</a>.
					</p>

					<p>To get started, you need to initialize the <code>Repository</code>
					object.  This is the starting point for most of what you will do with
					the libgit2 API.
					</p>

<span class="shtitle">C</span>
<pre class="sh_c">
#include &lt;git.h&gt;
git_repository *repo;
git_repository_open(&repo, "/path/to/repo.git");
git_repository_free(repo);
</pre>

<br/>

<span class="shtitle">Ruby</span>
<pre class="sh_ruby">
require 'rugged'
@repo = Rugged::Repository.new(@path)
</pre>

			</div>
			</div></div>



			<h2 id="sha">SHA1 Conversion and Formatting</h2>
			<div class="contents"><div class="bullet">
				<div class="description">

				<p>The Git object database is basically a key-value store wher
				the key for each object is the SHA1 checksum of the contents of
				the object it is storing. This means that working with these SHA1
				values is pretty important.  The SHA1 algorithm returns a 20-byte
				raw value for any content given to it, but in order to be readable
				by people or to even accurately represent it in ASCII, you have to
				convert the value to 40 hex characters.  libgit2 provides helper
				functions to easily do this conversion.</p>

			<h3>Hex to Raw</h3>

<span class="shtitle">C</span>
<pre class="sh_c">
char hex[] = "599955586da1c3ad514f3e65f1081d2012ec862d";
git_oid oid;
git_oid_mkstr(&oid, hex);
printf("Raw 20 bytes: [%s]\n", (&oid)->id);
</pre>

<br/>

<span class="shtitle">Ruby</span>
<pre class="sh_ruby">
raw = Rugged::hex_to_raw("ce08fe4884650f067bd5703b6a59a8b3b3c99a09")
puts "Raw 20 bytes: #{raw}"
</pre>

			<h3>Raw to Hex</h3>

<span class="shtitle">C</span>
<pre class="sh_c">
git_oid oid;
char out[40];

git_oid_mkraw(&oid, raw);
git_oid_fmt(out, &oid);
printf("SHA hex string: %s\n", out);$
</pre>

<br/>

<span class="shtitle">Ruby</span>
<pre class="sh_ruby">
hex = Rugged::raw_to_hex(Base64.decode64("FqASNFZ4mrze9Ld1ITwjqL109eA="))
puts "SHA hex string: #{hex}"
</pre>

				</div>
			</div></div>

			<h2 id="rawread">Raw Data Reading and Writing</h2>
			<div class="contents"><div class="bullet">
				<div class="description">

				<p>This is the lowest layer of Git access, raw read and write
				access to the object database. With libgit2 you can read the raw
				data of any object out of the database by providing the SHA1 hash
				of that object.  It will pull from loose or packed objects
				transparently.
				</p>

			<h3>Reading Data</h3>

<span class="shtitle">C</span>
<pre class="sh_c">
git_odb *odb;
git_rawobj obj;
git_oid oid;

unsigned char *data;
const char *str_type;
int error;

odb = git_repository_database(repo);
git_oid_mkstr(&oid, "599955586da1c3ad514f3e65f1081d2012ec862d");
error = git_odb_read(&obj, odb, oid);

data = obj.data;  // raw object data
str_type = git_obj_type_to_string(obj.type); // human readable object type
printf("object length and type: %d, %s\n", (int)obj.len, str_type)
</pre>

<br/>

<span class="shtitle">Ruby</span>
<pre class="sh_ruby">
sha = "599955586da1c3ad514f3e65f1081d2012ec862d"
if @repo.exists(sha)
  data, length, type = @repo.read(sha)
end
</pre>

			<p id="rawwrite">We also provide access to write arbitrary content back into
			the object database.  For writing blob contents, this is fine,
			but remember that other types such as commits and trees have very
			specific formats. It would be easy to introduce corrupt objects
			this way.</p>

			<h3>Writing Data</h3>

<span class="shtitle">C</span>
<pre class="sh_c">
git_odb *odb;
git_rawobj obj;
git_oid oid;
int error;
char out[40];

odb = git_repository_database(repo);

(&obj)->data = "any ol content will do";
(&obj)->len  = 22;
(&obj)->type = git_obj_string_to_type("blob");

git_obj_hash(&oid, &obj);
git_oid_fmt(out, &oid);
printf("SHA hex string: %s\n", out);

error = git_odb_write(&oid, odb, &obj);  // actually write to the db
</pre>

<br/>

<span class="shtitle">Ruby</span>
<pre class="sh_ruby">
content = "any ol content will do"
sha = @repo.hash(content, "blob")  # just gives you the SHA hash
sha = @repo.write(content, "blob") # actually writes to the odb
</pre>

				</div>
			</div></div>

			<h2 id="parsing">Object Parsing and Writing</h2>
			<div class="contents"><div class="bullet">
				<div class="description">
				<p>
					The different Git object types other than blobs have very specific
					formats they need to be in.  libgit2 is capable of properly parsing
					commits, tags, and trees for you. It can also construct the proper
					format given the raw data to for easy write-back capability.
				</p>

			<a class="apilink" href="http://libgit2.github.com/libgit2/group__git__commit.html">Commit API</a>
			<h3 id="commits">Commits</h3>


<span class="shtitle">C</span>
<pre class="sh_c">
git_commit *commit;
git_oid oid, tid;
int error;

git_oid_mkstr(&oid, "599955586da1c3ad514f3e65f1081d2012ec862d");

error = git_repository_lookup(&commit, repo, &oid, OBJ_COMMIT);

const git_person *author, *cmtter;
const char *message, *message_short;
time_t ctime;
unsigned int parents, p;

msg      = git_commit_message(commit);
msg      = git_commit_message_short(commit);
author   = git_commit_author(commit);
cmtter   = git_commit_committer(commit);
ctime    = git_commit_time(commit);

printf("Author: %s (%s)\n", author->name, author->email);

parents  = git_commit_parentcount(commit);
for (p = 0;p < parents;p++) {
  parent = git_commit_parent(commit, p);
}

/* And write a new object back, based on the original one */

git_tree *tree;
git_oid_mkstr(&tid, "07b3b552c4e879a21eb81d048fa729df65a49051");
git_tree_lookup(&tree, repo, &id);
git_commit_set_tree(commit, tree); // set tree to a different tree

// change the author, committer and message
git_commit_set_author(commit, "OP Chacon", "op@gmail.com", 987654321);
git_commit_set_committer(commit, "Orange Peel Chacon", "op@gmail.com", 123456789);
git_commit_set_message(commit, "the new commit message");

// write the object to disk
git_object_write((git_object *)commit);
</pre>

	<p>Notice that you can get objects from the database either via the 
	<code>git_[object]_lookup(&obj, repo, &id)</code> method or the more
	general <code>git_repository_lookup(&obj, repo, &oid, OBJ_TYPE)</code>
	call.  I will use them interchangably through these examples.</p>

<br/>

<span class="shtitle">Ruby</span>
<pre class="sh_ruby">
sha = "599955586da1c3ad514f3e65f1081d2012ec862d"
obj = @repo.lookup(sha)

obj.sha
obj.type
obj.message
obj.message_short
obj.time

c = obj.committer
c.name       # "Scott Chacon"
c.time.to_i  # 1273360386
c.email      # "schacon@gmail.com"

obj.tree.sha # "181037049a54a1eb5fab404658a3a250b44335d7"
obj.parents.each do |parent|
  pp parent
end

tree = @repo.lookup("07b3b552c4e879a21eb81d048fa729df65a49051")
obj.tree = tree

c.name = "Orange Peel Chacon"
c.email = "op@gmail.com"

obj.author = c
obj.committer = c
obj.message = "the new commit message"
obj.write  # write back to the database
</pre>

			<a class="apilink" href="http://libgit2.github.com/libgit2/group__git__tag.html">Tag API</a>
			<h3 id="tags">Tags</h3>

<span class="shtitle">C</span>
<pre class="sh_c">
git_tag *tag;
git_commit *commit;
git_oid oid;
int error;

git_oid_mkstr(&oid, "0c37a5391bbff43c37f0d0371823a5509eed5b1d");

error = git_repository_lookup(&tag, repo, &oid, OBJ_TAG);

git_tag_name(tag)    // "test"
git_tag_type(tag)    // GIT_OBJ_TAG
git_tag_message(tag) // "tag message\n"
commit = (git_commit *)git_tag_target(tag);
</pre>

<br/>

<span class="shtitle">Ruby</span>
<pre class="sh_ruby">
sha = "0c37a5391bbff43c37f0d0371823a5509eed5b1d"
obj = @repo.lookup(sha)

obj.sha
obj.type        # "tag"
obj.message     # "test tag message\n"
obj.name        # "v1.0"
obj.target.sha  # "5b5b025afb0b4c913b4c338a42934a3863bf3644"
obj.target_type # "commit"

c = obj.tagger
c.name      # "Scott Chacon"
c.time.to_i # 1288114383
c.email     # "schacon@gmail.com"
</pre>


			<a class="apilink" href="http://libgit2.github.com/libgit2/group__git__tree.html">Tree API</a>
			<h3 id="trees">Trees</h3>


<span class="shtitle">C</span>
<pre class="sh_c">
git_oid id;
git_tree *tree;
git_tree_entry *entry;
git_object *obj;

git_oid_mkstr(&id, "1810dff58d8a660512d4832e740f692884338ccd");

git_tree_lookup(&tree, repo, &id);

git_tree_entrycount(tree); // 3

entry = git_tree_entry_byname(tree, "README");
git_tree_entry_name(entry); // "README"

entry = git_tree_entry_byindex(tree, 0)
git_tree_entry_name(entry); // "README"

git_tree_entry_2object(&obj, entry); // blob
</pre>

<br/>

<span class="shtitle">Ruby</span>
<pre class="sh_ruby">
tree = @repo.lookup("1385f264afb75a56a5bec74243be9b367ba4ca08")
tree.sha
tree.type         # "tree"
tree.entry_count  # 3
tree.each do |entry|
  puts entry.name
  puts entry.to_object.sha
  puts entry.attributes
end

enumdir = tree.sort { |a, b| a.sha <=> b.sha }.map { |e| e.name }.join(':')
puts enumdir # "README:subdir:new.txt"
</pre>

			<a class="apilink" href="http://libgit2.github.com/libgit2/group__git__blob.html">Blob API</a>
			<h3 id="blobs">Blobs</h3>

<p>Since blobs are basically unstructured, there isn't a lot the blob routines
provide over the raw access calls, but there are some interesting methods to help
read in contents from disk.</p>

<span class="shtitle">C</span>
<pre class="sh_c">
git_oid id;
git_blob *blob;
git_object *obj;

git_oid_mkstr(&id, "1810dff58d8a660512d4832e740f692884338ccd");

git_blob_lookup(&blob, repo, &id);
git_blob_rawsize(blob);    // 8
git_blob_rawcontent(blob); // "content"

git_blob_set_rawcontent(blob, "my new content");
git_blob_set_rawcontent_fromfile(blob, "README.txt");
</pre>

<br/>

<span class="shtitle">Ruby</span>
<pre class="sh_ruby">
sha = "fa49b077972391ad58037050f2a75f74e3671e92"
blob = @repo.lookup(sha)
blob.size    # 9
blob.content # "new file\n"
blob.type    # "blob"

blob.content = "new blob content"
blob.write
</pre>

				</div>
			</div></div>

			<h2 id="revwalk">Revision Walking</h2>
			<div class="contents"><div class="bullet">
				<div class="description">

				<p>libgit2 also has a revision walking API that gives you access to the
				mechanics of the 'log' command.  Instead of just running 'git log', you
				start a graph walker, tell it where to start and just begin asking it
				for the next commit in the list.</p>

				<p>You can technically write your own walker by starting with any commit
				and continuously putting it's parents in a queue and then taking the 
				next commit off that queue, but the built in walker is faster and has a
				few different walking strategies built in.</p>

<span class="shtitle">C</span>
<pre class="sh_c">
git_oid id;
git_revwalk *walk;
git_commit *head, *commit;

git_oid_mkstr(&id, "d6c2306fcbf0d346b9129b303c3babae58f619f7");
git_commit_lookup(&head, repo, &id);

git_revwalk_new(&walk, repo);
git_revwalk_sorting(walk, GIT_SORT_TOPOLOGICAL | GIT_SORT_REVERSE);
git_revwalk_push(walk, head);

while ((commit = git_revwalk_next(walk)) != NULL) {
  msg      = git_commit_message_short(commit);
  author   = git_commit_author(commit);
  printf("%s (%s)\n", msg, author->email);
}

git_revwalk_free(walk);
</pre>

<br/>

<span class="shtitle">Ruby</span>
<pre class="sh_ruby">
walker = Rugged::Walker.new(@repo)
walker.push("d6c2306fcbf0d346b9129b303c3babae58f619f7")
while commit = walker.next
  msg   = commit.message
  email = commit.author.email
  puts "#{msg} (#{email})"
end
</pre>

				</div>
			</div></div>

			<h2 id="index">Index Manipulation</h2>
			<div class="contents"><div class="bullet">
				<div class="description">

<span class="shtitle">C</span>
<pre class="sh_c">
</pre>

<br/>

<span class="shtitle">Ruby</span>
<pre class="sh_ruby">
</pre>

				</div>
			</div></div>

	<a href="http://github.com/libgit2/libgit2" id="github">
		<img alt="Fork me on GitHub" src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" />
	</a>
</body>
</html>
